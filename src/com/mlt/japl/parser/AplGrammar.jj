/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.7";
  UNICODE_INPUT = true;
  LOOKAHEAD = 2;
  COMMON_TOKEN_ACTION = true;
  TOKEN_MANAGER_USES_PARSER = true;
  static = false;
}

PARSER_BEGIN(AplParser)
package com.mlt.japl.parser;

import java.io.Reader;
import com.mlt.japl.iface.*;
import com.mlt.japl.fns.*;
import com.mlt.japl.ast.*;
import com.mlt.japl.errors.*;
import com.mlt.japl.utils.FunctionRegistry;
import com.mlt.japl.workspace.*;

import java.util.ArrayList;
import java.util.List;

public class AplParser
{
  EvalContext context;
  FunctionRegistry fnRegistry;
  
  public AplParser(Reader reader, EvalContext context)
  {
    this(reader);
    this.context = context;
    this.fnRegistry = new FunctionRegistry();
  }

  public EvalContext getContext()
  {
    return context;
  }

  public Func lookupFn(String name)
  {
    Func fn = fnRegistry.lookup(name);
	if(fn==null) return context.tryGetFunction(name);
	else return fn;
  }

  public Func buildMonadicOperator(String n, Func arg)
  {
    Func fn = fnRegistry.buildMonadicOperator(n, arg);
    if(fn==null)
	    throw new SyntaxError();
	return fn;
  }
  
  public AstNode parse()
  {
     try
     {
		return apl_expr();
     } catch(ParseException e)
     {
		throw new SyntaxError();
     }
  }
}

PARSER_END(AplParser)

TOKEN_MGR_DECLS:
{
  // trick: check identifier if it is bound to function and make it a FUNC token
  // in effect modifies the parser dynamically
  public void CommonTokenAction(Token t)
  {
	EvalContext ctx = parser.getContext();
	if(t.kind==AplParserConstants.ID)
	{
		if(ctx.isBoundToFunction(t.image))
		{
		  t.kind = AplParserConstants.FUNC;
		}
	}
  }
}

SKIP :
{
  " "
| "\t"
| < "\u235d" (~["\n"])* ["\n"] >   // comments
}

TOKEN : /* OPERATORS */
{
  < FUNC:
    "\u003f"  // roll ?
  | "\u2308"  // ceil
  | "\u230a"  // floor
  | "\u2374"  // rho, shape
  | "\u223c"  // tilde (not)
  | "\u2223"  // abs
  | "\u2373"  // iota
  | "\u22c6"  // exponential
  | "\u2212"  // negation/sub
  | "\u002b"  // identity/add
  | "\u00d7"  // signum/mul
  | "\u00f7"  // reciprocal/divide
  | "\u002c"  // ravel,catenate
  | "\u2339"  // matrix inverse
  | "\u25cb"  // pi times
  | "\u235f"  // log
  | "\u233d"  // reverse last axis
  | "\u2296"  // reverse first axis
  | "\u234b"  // grade up
  | "\u2352"  // grade down
  | "\u234e"  // execute apl expr
  | "\u2355"  // format
  | "\u2349"  // transpose
  | "\u0021"  // factorial
  | "\u2208"  // epsilon, membership
  | "\u2191"  // take
  | "\u2193"  // drop
  | "\u22a5"  // decode
  | "\u22a4"  // encode
  | "\u2339"  // matrix divide
  | "\u2349"  // general transpose
  | "\u003c"  // less than
  | "\u2264"  // less than or equal
  | "\u003d"  // equal
  | "\u2265"  // greater than or equal
  | "\u003e"  // greater than
  | "\u2260"  // not equal
  | "\u2228"  // logical or
  | "\u2227"  // logical and
  | "\u2371"  // nor
  | "\u2372"  // nand
  | "\u2208"  // epsilon
  | "\u2261"  // depth
  | "\u2282"  // enclose
  | "\u2283"  // disclose
  | "\u222a"  // union
  | "\u22a3"  // stop
  | "\u22a2"  // pass
  | "⍪"  // laminate 1st axis
  >
| < OUTERPROD:
    "\u2218." >
| < MONADICOPERATOR:
    "/"
  | "\\"
  | "\u00a8"
  | "\u233f"
  | "\u2340"
  >
| < STMTSEPARATOR:
    "\u22c4"
  | (["\r","\n"])+
  | ("\u235d" (~["\n"])* ["\n"])
  >
}

TOKEN :
{
  < ID : (["a"-"z"]|["A"-"Z"]|["\u03b1"]|["\u03c9"]|["\u236c"]|["\u2395"])+ >
| < CONSTANT : < NUMBER > >
| < CPLXCONSTANT: < NUMBER > "J" < NUMBER > >
| < STRING : < STRINGDELIM > (< STRINGCHAR >)* < STRINGDELIM > >
| < #NUMBER: ((< SIGN >)? (< DIGIT >)+ ("." (< DIGIT >)+)?) >
| < #SIGN : ["¯"] >
| < #DIGIT : [ "0"-"9" ] >
| < #STRINGDELIM : ["'"] >
| < #STRINGCHAR : ~["'"] >
}

// execute top level expressions one at a time
void eval_stream() :
{
  AstNode t;}
{
    (< STMTSEPARATOR >)? t=toplevelexpr()    {
      t.eval(context);    }	(< STMTSEPARATOR > t=toplevelexpr()	  {
	    t.eval(context);	  })*
    (< STMTSEPARATOR >)?
	< EOF >
}

// single expression is either monadic/niladic call or dyadic call/array
AstNode toplevelexpr() :
{
  AstNode t;
}
{
 	t = repeat_expr()
 	{
		return t;
 	} 
|   t = if_expr()
    {
      return t;
    }
|   t = while_expr()
	{
	  return t;
	}
|   t = arrayexpr()
	{
	  return t;
	}
}

AstNode toplevel_expr_list() :
{
  AstNode t;
  AstNode c;
  List<AstNode> statements = new ArrayList<AstNode>();
}
{
	(< STMTSEPARATOR >)? t = toplevelexpr()
	(< STMTSEPARATOR > c=toplevelexpr()
		{
		  statements.add(c);
		}
	)*
	(< STMTSEPARATOR >)?
	{
	  if(statements.size()==0) return t;
	  statements.add(0, t);
	  return new StatementListNode(statements);
	}
}

// top level expression ends with EOF
AstNode apl_expr() :
{
  AstNode t;
}
{
	t = toplevelexpr() < EOF >
	{
	  return t;
	}
}

// expression is a single expression or a list of expressions

AstNode arrayexpr() :{	AstNode t;
}
{   t = monadic_call_or_niladic()
  	{
  	  return t;
  	}
|   t = dyadic_call_or_array()
	{
	  return t;
	}
}

AstNode if_expr() :
{  AstNode cond, thenbranch, elsebranch=null;
}
{	":If" cond=arrayexpr() ":Then" thenbranch=toplevel_expr_list() (":Else" elsebranch=toplevel_expr_list())? ":EndIf"
	{
	  return new IfNode(cond, thenbranch, elsebranch);	}
}

AstNode while_expr() :
{
  AstNode cond, body;
}
{
	":While" cond=arrayexpr() ":Do" body=toplevel_expr_list() ":EndWhile"
	{
	  return new WhileNode(cond, body);
	}
}

AstNode repeat_expr() :
{
  AstNode count, body;}
{
  ":Repeat" count=arrayexpr() ":Do" body=toplevel_expr_list() ":EndRepeat"
  {
    return new RepeatNode(count, body);  }}

// monadic call starts with a function expression, followed by optional axis expression and
// argument expr
AstNode monadic_call_or_niladic() :
{
  Func s;
  AstNode t = null;
  AstNode arg = null;
  AstNode axis = null;
}
{
  s=fn_expr() ("[" axis=arrayexpr() "]")? (t=arrayexpr())?
  {
    if(t!=null)
    {
      return new MonadicCallNode(s, t, axis);
    } else
    {
      return new NiladicCallNode(s);
    }
  }
}

// dyadic call starts with an array, followed by function expression, possible axis expr and right
// single expression
AstNode dyadic_call_or_array() :
{
  AstNode left;
  Func op = null;
  AstNode right = null;
  AstNode axis = null;
}
{
  left=array() (op=fn_expr() ("[" axis=arrayexpr() "]")? right=arrayexpr())?
  {
    if(op!=null)
    {
		return new DyadicCallNode(op, left, right, axis);
    } else
    {
		return left;
    }
  }
}

// array is a sequence of 1 or more elements (identifiers, paren-enclosed expressions, constants)
AstNode array() :
{
  AstNode idexpr = null;
  Token s;
  boolean mustEvaluate = false;
  List<AstNode > nodeList = new ArrayList<AstNode>();
}
{
	(idexpr = identifierexpr()
	  {
	    nodeList.add(idexpr);
	    mustEvaluate = true;
	  }
	| s = < CONSTANT >
	  {
	    nodeList.add(new ConstantAstNode(s.toString()));
	  }
    | s = < STRING >
      {
	    nodeList.add(new ConstantAstNode(s.toString()));
      }
    | s = < CPLXCONSTANT >
	  {
	    nodeList.add(new ConstantAstNode(s.toString(), ConstantAstNode.COMPLEX));
	  }
	| "(" idexpr = arrayexpr()
	  {
	    nodeList.add(idexpr);
	    mustEvaluate = true;
	  }
	  ")")+
	{
	  if(mustEvaluate)
	  {
	    if(nodeList.size()==1) return nodeList.get(0);
	    return new EvalArrayNode(nodeList);
	  }
	  else
	  {
	    if(nodeList.size()==1) return nodeList.get(0);
		return new ConstArrayNode(nodeList);
	  }
	}
}

AstNode identifierexpr() :
{
  AstNode e = null;
  AstNode e2 = null;
  Token ident = null;
}
{
  ident = < ID > ("[" e = indexexpr() "]")? ("←" e2=arrayexpr())?
  {
    if(e2!=null)
    	return new AssignmentNode(ident.toString(), e2);
    else
	    return new IdentifierNode(ident.toString(), e);
  }
}

IndexExprNode indexexpr() :
{
  AstNode e1 = null;
  IndexExprNode e2 = null;
}
{
  (e1=arrayexpr())? (";" e2=indexexpr())?
  {
    return new IndexExprNode(e1, e2);
  }
}

Func fn_expr() :
{
  Func s = null;
  AstNode userfn = null;
  Token m = null;
}
{
    userfn = userfndef() { return new UserFnNode(userfn, context); }
  | s = operatorexpr() (m = < MONADICOPERATOR >)? {
       if(m!=null)
         return buildMonadicOperator(m.toString(), s);
       else
    	 return s;
    }
}

AstNode userfndef() :
{
  AstNode fnBody = null;
}
{
  "{" fnBody = toplevel_expr_list() "}"
  {
    return fnBody;
  }
}

Func operatorexpr() :
{
  Func right = null;
}
{
  right = function_or_inner_product()
  {
    return right;
  }
| right =monadic_operator_as_fn()
  {
    return right;
  }
| right = outer_product()
  {
	return right;
  }
}

Func outer_product() :
{
  Func right = null;
}
{
	< OUTERPROD > right = operatorexpr()
	{
	  return new OuterProdFn(right);
	}
}

Func monadic_operator_as_fn() :
{
  Token s = null;
}
{
	s = < MONADICOPERATOR >
	{
	  return lookupFn(s.toString());
	}
}

Func operatorexpr_noinnerprod() :
{
  	Func s = null;
  	Token t = null;
}
{
	s = outer_product()
	{
	  return s;
	}
|   s = monadic_operator_as_fn()
    {
      return s;
    }
|   t = < FUNC >
    {
      return lookupFn(t.toString());
    }
}

Func function_or_inner_product() :
{
  Token s = null;
  Token t = null;
  Func right = null;
  List<Func> chain = new ArrayList<Func>();
}
{
	s = < FUNC > ("." right = operatorexpr_noinnerprod()
	{
	  chain.add(right);
	})*
	{
	  if(chain.size() > 1)
	  {
	    chain.add(0,lookupFn(s.toString()));
	    Func x = chain.get(0);
	    for(int i=1; i<chain.size(); i++)
	    {
	      x = new InnerProdFn(x, chain.get(i));
	    }
		return x;
	  }
	  else if(chain.size()==1)
	  {
	    return new InnerProdFn(lookupFn(s.toString()), chain.get(0));
	  }
	  else
	  {
	     return lookupFn(s.toString());
	  }
	}
}
